<!DOCTYPE HTML>
<!--
	Prologue by HTML5 UP
	html5up.net | @n33co
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Boost Application Development Cookbook Online Examples (BETA)</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="assets/css/main.min.css" />
		<!--[if lte IE 8]><link rel="stylesheet" href="assets/css/ie8.css" /><![endif]-->
		<!--[if lte IE 9]><link rel="stylesheet" href="assets/css/ie9.css" /><![endif]-->
		<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
		<style type="text/css" media="screen">
			#code { 
				width: 100%;
				float:left;
				min-height:100px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<!-- Header -->
			<div id="header">

				<div class="top">

						<div id="logo">
							<h1 id="title">Online Examples (BETA)</h1>
							<p>Boost Application Development Cookbook</p><img src="images/4880OS.jpg" style="width: 100%; float: right" alt="Book cover"/>
						</div>

					<!-- Nav -->
						<nav id="nav">
							<!--
								Prologue's nav expects links in one of two formats:
								1. Hash link (scrolls to a different section within the page)
								   <li><a href="#foobar" id="foobar-link" class="icon fa-whatever-icon-you-want skel-layers-ignoreHref"><span class="label">Foobar</span></a></li>
								2. Standard link (sends the user to another page/site)
								   <li><a href="http://foobar.tld" id="foobar-link" class="icon fa-whatever-icon-you-want"><span class="label">Foobar</span></a></li>
							-->
							<ul>
								<li><a href="#top" id="top-link" class="skel-layers-ignoreHref"><span class="icon fa-book">Heading</span></a></li>
								<li><a href="#chapters" id="chapters-link" class="skel-layers-ignoreHref"><span class="icon fa-home">Chapters</span></a></li>
								<li><a href="#intros" id="intros-link" class="skel-layers-ignoreHref"><span class="icon fa-info">Recipe's Intro</span></a></li>
								<li><a href="#online_run" id="online_run-link" class="skel-layers-ignoreHref"><span class="icon fa-gear">Compile &amp; Run</span></a></li>
								<li><a href="#about" id="about-link" class="skel-layers-ignoreHref"><span class="icon fa-user">About</span></a></li>
								<li><a href="#acknowledgements" id="acknowledgements-link" class="skel-layers-ignoreHref"><span class="icon fa-envelope">Thanks</span></a></li>
							</ul>
						</nav>

				</div>

				<div class="bottom">
				</div>

			</div>

		<!-- Main -->
			<div id="main">

				<!-- Intro -->
					<section id="top" class="one dark cover">
						<div class="container">

							<header>
								<h2 class="alt">
								<strong>Boost Application Development Cookbook</strong><br> Online Examples (BETA)</h2>
								<p>This site contains all the source codes from <a href="http://www.packtpub.com/boost-cplusplus-application-development-cookbook/book">the book</a>.
								<br>You are free to experiment with code, compile, modify, run and use examples.</p>

							</header>

						</div>
					</section>

					<section id="chapters" class="two">
						<div class="container">

							<div class="right" style="margin: 0.5em 0.5em 0 3em">
								<p><button title="Expand TOC and show all recipes" id="show_all_button" onclick='editor.chapter_show_all();'><span class="icon fa-toggle-down"></span></button>
										- Show all recipes</p>
								<p><button title="Show only chapters in TOC" id="hide_all_button" onclick='editor.chapter_hide_all();'><span class="icon fa-toggle-up"></span></button>
										- Hide all recipes</p>
							</div>

							<h2 id="Chapter00_ref">Chapters</h2>
							<h4>Click on the chapter to view it's recipes. Click on the recipe to see it's sources.</h4>


							<div class="left">
								<ul>
									<li>
										<a id="Chapter01_ref" href="javascript:editor.chapter_toggle('01');">Chapter 01: Starting to Write Your Application</a>
										<ul class="hidden" id="Chapter01">
<li><a href="javascript:editor.download('Chapter01', 0)">Getting configuration options (part 1</a>, <a href="javascript:editor.download('Chapter01', 0, 1)">part 2</a>)</li>
<li><a href="javascript:editor.download('Chapter01', 1)">Storing any value in a container/variable</a></li>
<li><a href="javascript:editor.download('Chapter01', 2)">Storing multiple chosen types in a variable/container</a></li>
<li><a href="javascript:editor.download('Chapter01', 3)">Using a safer way to work with a container that stores multiple chosen types (part 1</a>, <a href="javascript:editor.download('Chapter01', 3, 1)">part 2</a>)</li>
<li><a href="javascript:editor.download('Chapter01', 4)">Returning a value or flag where there is no value</a></li>
<li><a href="javascript:editor.download('Chapter01', 5)">Returning an array from a function</a></li>
<li><a href="javascript:editor.download('Chapter01', 6)">Combining multiple values into one</a></li>
<li><a href="javascript:editor.download('Chapter01', 7)">Reordering the parameters of function</a></li>
<li><a href="javascript:editor.download('Chapter01', 8)">Binding a value as a function parameter</a></li>
<li><a href="javascript:editor.download('Chapter01', 9)">Using the C++11 move emulation</a></li>
<li><a href="javascript:editor.download('Chapter01', 10)">Making a noncopyable class</a></li>
<li><a href="javascript:editor.download('Chapter01', 11)">Making a noncopyable but movable class</a></li>
										</ul>
									</li>
									<li>
										<a id="Chapter02_ref" href="javascript:editor.chapter_toggle('02');">Chapter 02: Converting Data</a>
										<ul class="hidden" id="Chapter02">
<li><a href="javascript:editor.download('Chapter02', 0)">Converting strings to numbers</a></li>
<li><a href="javascript:editor.download('Chapter02', 1)">Converting numbers to strings</a></li>
<li><a href="javascript:editor.download('Chapter02', 2)">Converting numbers to numbers</a></li>
<li><a href="javascript:editor.download('Chapter02', 3)">Converting user-defined types to/from strings</a></li>
<li><a href="javascript:editor.download('Chapter02', 4)">Casting polymorphic objects</a></li>
<li><a href="javascript:editor.download('Chapter02', 5)">Parsing simple input</a></li>
<li><a href="javascript:editor.download('Chapter02', 6)">Parsing input</a></li>
										</ul>
									</li>
									<li>
										<a id="Chapter03_ref" href="javascript:editor.chapter_toggle('03');">Chapter 03: Managing Resources</a>
										<ul class="hidden" id="Chapter03">
<li><a href="javascript:editor.download('Chapter03', 0)">Managing pointers to classes that do not leave scope</a></li>
<li><a href="javascript:editor.download('Chapter03', 1)">Reference counting of pointers to classes used across methods</a></li>
<li><a href="javascript:editor.download('Chapter03', 2)">Managing pointers to arrays that do not leave scope</a></li>
<li><a href="javascript:editor.download('Chapter03', 3)">Reference counting pointers to arrays used across methods</a></li>
<li><a href="javascript:editor.download('Chapter03', 4)">Storing any functional objects in a variable (part 1</a>, <a href="javascript:editor.download('Chapter03', 4, 1)">part 2</a>)</li>
<li><a href="javascript:editor.download('Chapter03', 5)">Passing a function pointer in a variable</a>)</li>
<li><a href="javascript:editor.download('Chapter03', 6)">Passing C++11 lambda functions in a variable</a></li>
<li><a href="javascript:editor.download('Chapter03', 7)">Containers of pointers</a></li>
<li><a href="javascript:editor.download('Chapter03', 8)">Doing something at scope exit</a></li>
<li><a href="javascript:editor.download('Chapter03', 9)">Initializing the base class by a member of the derived class</a></li>
										</ul>
									</li>
									<li>
										<a id="Chapter04_ref" href="javascript:editor.chapter_toggle('04');">Chapter 04: Compile-time Tricks</a>
										<ul class="hidden" id="Chapter04">
<li><a href="javascript:editor.download('Chapter04', 0)">Checking sizes at compile time</a></li>
<li><a href="javascript:editor.download('Chapter04', 1)">Enabling the usage of templated functions for integral types</a></li>
<li><a href="javascript:editor.download('Chapter04', 2)">Disabling templated functions' usage for real types</a></li>
<li><a href="javascript:editor.download('Chapter04', 3)">Creating a type from number</a></li>
<li><a href="javascript:editor.download('Chapter04', 4)">Implementing a type trait</a></li>
<li><a href="javascript:editor.download('Chapter04', 5)">Selecting an optimal operator for a template parameter</a></li>
<li><a href="javascript:editor.download('Chapter04', 6)">Getting a type of expression in C++03</a></li>
										</ul>
									</li>
									<li>
										<a id="Chapter05_ref" href="javascript:editor.chapter_toggle('05');">Chapter 05: Multithreading</a>
										<ul class="hidden" id="Chapter05">
<li><a href="javascript:editor.download('Chapter05', 0)">Creating an execution thread</a></li>
<li><a href="javascript:editor.download('Chapter05', 1)">Syncing access to a common resource</a></li>
<li><a href="javascript:editor.download('Chapter05', 2)">Fast access to common resource using atomics</a></li>
<li><a href="javascript:editor.download('Chapter05', 3)">Creating a work_queue class</a></li>
<li><a href="javascript:editor.download('Chapter05', 4)">Multiple-readers-single-writer lock</a></li>
<li><a href="javascript:editor.download('Chapter05', 5)">Creating variables that are unique per thread</a></li>
<li><a href="javascript:editor.download('Chapter05', 6)">Interrupting a thread</a></li>
<li><a href="javascript:editor.download('Chapter05', 7)">Manipulating a group of threads</a></li>
										</ul>
									</li>
									<li>
										<a id="Chapter06_ref" href="javascript:editor.chapter_toggle('06');">Chapter 06: Manipulating Tasks</a>
										<ul class="hidden" id="Chapter06">
<li><a href="javascript:editor.download('Chapter06', 0)">Registering a task for processing an arbitrary datatype (part 1</a>, <a href="javascript:editor.download('Chapter06', 0, 1)">part 2</a>)</li>
<li><a href="javascript:editor.download('Chapter06', 1)">Making timers and processing timer events as tasks (part 1</a>, <a href="javascript:editor.download('Chapter06', 1, 1)">part 2</a>)</li>
<li><a href="javascript:editor.download('Chapter06', 2)">Network communication as a task (part 1</a>, <a href="javascript:editor.download('Chapter06', 2, 1)">part 2</a>)</li>
<li><a href="javascript:editor.download('Chapter06', 3)">Accepting incoming connections (part 1</a>, <a href="javascript:editor.download('Chapter06', 3, 1)">part 2</a>)</li>
<li><a href="javascript:editor.download('Chapter06', 4)">Executing different tasks in parallel (part 1</a>, <a href="javascript:editor.download('Chapter06', 4, 1)">part 2</a>)</li>
<li><a href="javascript:editor.download('Chapter06', 5)">Conveyor tasks processing</a></li>
<li><a href="javascript:editor.download('Chapter06', 6)">Making a nonblocking barrier</a></li>
<li><a href="javascript:editor.download('Chapter06', 7)">Storing an exception and making a task from it</a></li>
<li><a href="javascript:editor.download('Chapter06', 8)">Getting and processing system signals as tasks (part 1</a>, <a href="javascript:editor.download('Chapter06', 8, 1)">part 2</a>)</li>
										</ul>
									</li>

									<li>
										<a id="Chapter07_ref" href="javascript:editor.chapter_toggle('07');">Chapter 07: Manipulating Strings</a>
										<ul class="hidden" id="Chapter07">
<li><a href="javascript:editor.download('Chapter07', 0)">Changing cases and case-insensitive comparison</a></li>
<li><a href="javascript:editor.download('Chapter07', 1)">Matching strings using regular expressions</a></li>
<li><a href="javascript:editor.download('Chapter07', 2)">Searching and replacing strings using regular expressions</a></li>
<li><a href="javascript:editor.download('Chapter07', 3)">Formatting strings using safe printf-like functions</a></li>
<li><a href="javascript:editor.download('Chapter07', 4)">Replacing and erasing strings</a></li>
<li><a href="javascript:editor.download('Chapter07', 5)">Representing a string with two iterators</a></li>
<li><a href="javascript:editor.download('Chapter07', 6)">Using a reference to string type</a></li>
										</ul>
									</li>
									<li>
										<a id="Chapter08_ref" href="javascript:editor.chapter_toggle('08');">Chapter 08: Metaprogramming</a>
										<ul class="hidden" id="Chapter08">
<li><a href="javascript:editor.download('Chapter08', 0)">Using type "vector of types"</a></li>
<li><a href="javascript:editor.download('Chapter08', 1)">Manipulating a vector of types</a></li>
<li><a href="javascript:editor.download('Chapter08', 2)">Getting a function's result type at compile time</a></li>
<li><a href="javascript:editor.download('Chapter08', 3)">Making a higher-order metafunction</a></li>
<li><a href="javascript:editor.download('Chapter08', 4)">Evaluating metafunctions lazily</a></li>
<li><a href="javascript:editor.download('Chapter08', 5)">Converting all the tuple elements to strings</a></li>
<li><a href="javascript:editor.download('Chapter08', 6)">Splitting tuples</a></li>
										</ul>
									</li>
									<li>
										<a id="Chapter09_ref" href="javascript:editor.chapter_toggle('09');">Chapter 09: Containers</a>
										<ul class="hidden" id="Chapter09">
<li><a href="javascript:editor.download('Chapter09', 0)">Comparing strings in an ultra-fast manner</a></li>
<li><a href="javascript:editor.download('Chapter09', 1)">Using an unordered set and map</a></li>
<li><a href="javascript:editor.download('Chapter09', 2)">Making a map, where value is also a key</a></li>
<li><a href="javascript:editor.download('Chapter09', 3)">Using multi-index containers</a></li>
<li><a href="javascript:editor.download('Chapter09', 4)">Getting the benefits of single-linked list and memory pool</a></li>
<li><a href="javascript:editor.download('Chapter09', 5)">Using flat associative containers</a></li>
										</ul>
									</li>
									<li>
										<a id="Chapter10_ref" href="javascript:editor.chapter_toggle('10');">Chapter 10: Gathering Platform and Compiler Information</a>
										<ul class="hidden" id="Chapter10">
<li><a href="javascript:editor.download('Chapter10', 0)">Detecting int128 support</a></li>
<li><a href="javascript:editor.download('Chapter10', 1)">Detecting RTTI support</a></li>
<li><a href="javascript:editor.download('Chapter10', 2)">Speeding up compilation using C++11 extern templates</a></li>
<li><a href="javascript:editor.download('Chapter10', 3)">Writing metafunctions using simpler methods</a></li>
<li><a href="javascript:editor.download('Chapter10', 4)">Reducing code size and increasing performance of user-defined types (UDTs) in C++11</a></li>
<li><a href="javascript:editor.download('Chapter10', 5)">The portable way to export and import functions and classes (part 1</a>, <a href="javascript:editor.download('Chapter10', 5, 1)">part 2</a>, <a href="javascript:editor.download('Chapter10', 5, 2)">part 3</a>)</li>
<li><a href="javascript:editor.download('Chapter10', 6)">Detecting the Boost version and getting latest features</a></li>
										</ul>
									</li>
									<li>
										<a id="Chapter11_ref" href="javascript:editor.chapter_toggle('11');">Chapter 11: Working with the System</a>
										<ul class="hidden" id="Chapter11">
<li><a href="javascript:editor.download('Chapter11', 0)">Listing files in a directory</a></li>
<li><a href="javascript:editor.download('Chapter11', 1)">Erasing and creating files and directories</a></li>
<li><a href="javascript:editor.download('Chapter11', 2)">Passing data quickly from one process to another</a></li>
<li><a href="javascript:editor.download('Chapter11', 3)">Syncing interprocess communications</a></li>
<li><a href="javascript:editor.download('Chapter11', 4)">Using pointers in shared memory</a></li>
<li><a href="javascript:editor.download('Chapter11', 5)">The fastest way to read files</a></li>
<li><a href="javascript:editor.download('Chapter11', 6)">Coroutines – saving the state and postponing the execution</a></li>
										</ul>
									</li>
									<li>
										<a id="Chapter12_ref" href="javascript:editor.chapter_toggle('12');">Chapter 12: Scratching the Tip of the Iceberg</a>
										<ul class="hidden" id="Chapter12">
<li><a href="javascript:editor.download('Chapter12', 0)">Working with graphs</a></li>
<li><a href="javascript:editor.download('Chapter12', 1)">Visualizing graphs</a></li>
<li><a href="javascript:editor.download('Chapter12', 2)">Using a true random number generator</a></li>
<li><a href="javascript:editor.download('Chapter12', 3)">Using portable math functions</a></li>
<li><a href="javascript:editor.download('Chapter12', 4)">Writing test cases</a></li>
<li><a href="javascript:editor.download('Chapter12', 5)">Combining multiple test cases in one test module (part 1</a>, <a href="javascript:editor.download('Chapter12', 5, 1)">part 2</a>, <a href="javascript:editor.download('Chapter12', 5, 2)">part 3</a>, <a href="javascript:editor.download('Chapter12', 5, 3)">part 4</a>, <a href="javascript:editor.download('Chapter12', 5, 4)">part 5</a>)</li>
<li><a href="javascript:editor.download('Chapter12', 6)">Manipulating images (part 1</a>, <a href="javascript:editor.download('Chapter12', 6, 1)">part 2</a>)</li>
										</ul>
									</li>
								</ul>
							</div>

						</div>
					</section>

					<section class="three">
						<div class="container">
							<div class="width100 left" id="online_example">

								<div id="intros" class="right" style="margin: 0.5em 0.5em">
									<button title="To previous recipe" onclick='editor.prev(); editor.set_local_url();'><span class="icon fa-angle-left"></span></button>
									<button title="To chapters list" onclick='$("#chapters-link").click();'><span class="icon fa-home"></span></button>
									<button title="To next recipe" onclick='editor.next(); editor.set_local_url();'><span class="icon fa-angle-right"></span></button>
								</div>
								<h3>Recipe's Intro</h3>
								<h4 id="recipe_title" class="width100"><span class="icon fa-bookmark-o"></span> Recipe: Getting configuration options</h4><br>


<div class="code-intro" id="Chapter01-0">
	<p>Take a look at some of the console programs, such as <code>cp</code> in Linux. They all have a fancy help,
	their input parameters do not depend on any position, and have a human readable syntax,
	for example:</p>
	<pre><code>
    $ cp --help

    Usage: cp [OPTION]... [-T] SOURCE DEST
        -a, --archive       same as -dR --preserve=all
        -b                  like --backup but does not accept an argument
</code></pre>
	<p>You can implement the same functionality for your program in 10 minutes. And all you need
	is the Boost.ProgramOptions library.</p>
</div>

<div class="code-intro" id="Chapter01-1">
	<p>If you have been programming in Java, C#, or Delphi, you will definitely miss the ability to
	create containers with the <code>Object</code> value type in C++. The <code>Object</code> class in those languages is
	a basic class for almost all types, so you are able to assign (almost) any value to it at any time.</p>
	<p>Just imagine how great it would be to have such a feature in C++</p>
</div>

<div class="code-intro" id="Chapter01-2">
	<p>Are you aware of the concept of unrestricted unions in C++11? Let me tell you about it in
	short. C++03 unions can only hold extremely simple types of data called POD (plain old data).
	So in C++03, you cannot, for example, store <code>std::string</code> or <code>std::vector</code> in a union.
	C++11 relaxes this requirement, but you'll have to manage the construction and destruction
	of such types by yourself, call in-place construction/destruction, and remember what type is
	stored in a union. A huge amount of work, isn't it?</p>
</div>

<div class="code-intro" id="Chapter01-3">
	<p>Imagine that you are creating a wrapper around some SQL database interface. You decided
	that <code>boost::any</code> will perfectly match the requirements for a single cell of the database
	table. Some other programmer will be using your classes, and his task would be to get a
	row from the database and count the sum of the arithmetic types in a row.</p>
</div>

<div class="code-intro" id="Chapter01-4">
	<p>Imagine that we have a function that does not throw an exception and returns a value or
	indicates that an error has occurred. In Java or C# programming languages, such cases are
	handled by comparing a return value from a function value with a <code>null</code> pointer; if it is <code>null</code> then
	an error has occurred. In C++, returning a pointer from a function confuses library users and
	usually requires dynamic memory allocation (which is slow).</p>
</div>

<div class="code-intro" id="Chapter01-5">
	<p>Let's play a guessing game! What can you tell about the following function?</p>
	<pre><code>
    char* vector_advance(char* val);
</code></pre>

	<p>Should return values be deallocated by the programmer or not? Does the function attempt
	to deallocate the input parameter? Should the input parameter be zero-terminated, or should
	the function assume that the input parameter has a specified width?
	And now, let's make the task harder! Take a look at the following line:</p>
	<pre><code>
    char ( &amp;vector_advance( char (&amp;val)[4] ) )[4];
</code></pre>
	<p>Please do not worry; I've also been scratching my head for half an hour before getting an idea
	of what is happening here. <code>vector_advance</code> is a function that accepts and returns an array
	of four elements. Is there a way to write such a function clearly?</p>
</div>

<div class="code-intro" id="Chapter01-6">
	<p>There is a very nice present for those who like <code>std::pair</code>. Boost has a library called Boost.Tuple,
	and it is just like <code>std::pair</code>, but it can also work with triples, quads, and even bigger
	collections of types.</p>
</div>

<div class="code-intro" id="Chapter01-7">
	<p>This recipe and the next one are devoted to a very interesting library, whose functionality at
	first glance looks like some kind of magic. This library is called Boost.Bind and it allows
	you to easily create new functional objects from functions, member functions, and functional
	objects, also allowing the reordering of the initial function's input parameters and binding
	some values or references as function parameters.</p>
</div>

<div class="code-intro" id="Chapter01-8">
	<p>If you work with the STL library a lot and use the <code>&lt;algorithm&gt;</code> header, you will definitely
	write a lot of functional objects. You can construct them using a set of STL adapter functions
	such as <code>bind1st</code>, <code>bind2nd</code>, <code>ptr_fun</code>, <code>mem_fun</code>, and <code>mem_fun_ref</code>, or you can write them
	by hand (because adapter functions look scary). Here is some good news: Boost.Bind can
	be used instead of all of those functions and it provides a more human-readable syntax.</p>
</div>

<div class="code-intro" id="Chapter01-9">
	<p>One of the greatest features of the C++11 standard is rvalue references. This feature allows
	us to modify temporary objects, "stealing" resources from them. As you can guess, the C++03
	standard has no rvalue references, but using the Boost.Move library you can write some
	portable code that uses them, and even more, you actually get started with the emulation of
	move semantics.</p>
</div>

<div class="code-intro" id="Chapter01-10">
	<p>You must have almost certainly encountered situations where providing a copy constructor
	and move assignment operator for a class will require too much work, or where a class owns
	some resources that must not be copied for technical reasons:</p>
	<pre><code>
    class descriptor_owner {
        void* descriptor_;

    public:
        explicit descriptor_owner(const char* params);

        ~descriptor_owner() {
            system_api_free_descriptor(descriptor_);
        }
    };
</code></pre>
	<p>The C++ compiler, in the case of the previous example, will generate a copy constructor and
	an assignment operator, so the potential user of the descriptor_owner class will be able
	to create the following awful things:</p>
	<pre><code>
    descriptor_owner d1("O_o");
    descriptor_owner d2("^_^");

    // Descriptor of d2 was not correctly freed
    d2 = d1;

    // destructor of d2 will free the descriptor
    // destructor of d1 will try to free already freed descriptor
</code></pre>
</div>

<div class="code-intro" id="Chapter01-11">
	<p>Now imagine the following situation: we have a resource that cannot be copied, which should
	be correctly freed in a destructor, and we want to return it from a function:</p>
	<pre><code>
    descriptor_owner construct_descriptor() {
        return descriptor_owner("Construct using this string");
    }
</code></pre>

	<p>Actually, you can work around such situations using the swap method:</p>
    <pre><code>
    void construct_descriptor1(descriptor_owner& ret) {
        descriptor_owner("Construct using this string").swap(ret);
    }
</code></pre>
	<p>But such a workaround won't allow us to use descriptor_owner in STL or Boost containers.
	And by the way, it looks awful!</p>
</div>



<div class="code-intro" id="Chapter02-0">
	<p>Converting strings to numbers in C++ makes a lot of people depressed because of its
	inefficiency and user unfriendliness. Let's see how string 100 can be converted to <code>int</code>:</p>
	<pre><code>
    #include &lt;sstream&gt;
    std::istringstream iss("100");
    int i;
    iss >> i;
    // And now, 'iss' variable will get in the way all the time,
    // till end of the scope
    // It is better not to think, how many unnecessary operations,
    // virtual function calls and memory allocations occurred
    // during those operations
</code></pre>
	<p>C methods are not much better:</p>
	<pre><code>
    #include &lt;cstdlib&gt;
    char * end;
    int i = std::strtol ("100", &amp;end, 10);
    // Did it converted all the value to int, or stopped somewhere
    // in the middle?
    // And now we have 'end' variable will getting in the way
    // By the way, we want an integer, but strtol returns long
    // int... Did the converted value fit in int?
</code></pre>
</div>

<div class="code-intro" id="Chapter02-1">
	<p>In this recipe we will continue discussing lexical conversions, but now we will be converting
	numbers to strings using Boost.LexicalCast . And as usual, <code>boost::lexical_cast</code>
	will provide a very simple way to convert the data.</p>
</div>

<div class="code-intro" id="Chapter02-2">
	<p>You might remember situations where you wrote something like the following code:</p>
	<pre><code>
    void some_function(unsigned short param);
    int foo();
    // Somewhere in code
    // Some compilers may warn that int is being converted to
    // unsigned short and that there is a possibility of losing
    // data
    some_function(foo());
</code></pre>
	<p>Usually, programmers just ignore such warnings by implicitly casting to unsigned short
	datatype, as demonstrated in the following code snippet:</p>
    <pre><code>
    // Warning suppressed. Looks like a correct code
    some_function(
        static_cast&lt;unsigned short&gt;(foo())
    );
</code></pre>
	<p>But this may make it extremely hard to detect errors. Such errors may exist in code for years
	before they get caught:</p>
	<pre><code>
    // Returns -1 if error occurred
    int foo() {
        if (some_extremely_rare_condition()) {
            return -1;
        } else if (another_extremely_rare_condition()) {
            return 1000000;
        }
        return 65535;
    }
</code></pre>
</div>


<div class="code-intro" id="Chapter02-3">
	<p>There is a feature in Boost.LexicalCast that allows users to use their own types in
	lexical_cast . This feature just requires the user to write the correct <code>std::ostream</code>
	and <code>std::istream</code> operators for their types.</p>
</div>

<div class="code-intro" id="Chapter02-4">
	<p>Imagine that some programmer designed an awful interface as follows (this is a good example
	of how interfaces should not be written):</p>
	<pre><code>
    struct object {
        virtual ~object() {}
    };

    struct banana: public object {
        void eat() const {}
        virtual ~banana(){}
    };

    struct pidgin: public object {
        void fly() const {}
        virtual ~pidgin(){}
    };

    object* try_produce_banana();
</code></pre>
	<p>Our task is to make a function that eats bananas, and throws exceptions if something
	instead of banana came along (eating pidgins gross!). If we dereference a value returned
	by the <code>try_produce_banana()</code> function, we are getting in danger of dereferencing
	a null pointer.</p>
</div>


<div class="code-intro" id="Chapter02-5">
	<p>It is a common task to parse a small text. And such situations are always a dilemma: shall we
	use some third-party professional tools for parsing such as Bison or ANTLR, or shall we try to
	write it by hand using only C++ and STL? The third-party tools are good for handling the parsing
	of complex texts and it is easy to write parsers using them, but they require additional tools
	for creating C++ or C code from their grammar, and add more dependencies to your project.
	Handwritten parsers are usually hard to maintain, but they require nothing except C++ compiler.</p>

	<p>Let's start with a very simple task to parse a date in ISO format as follows:</p>
	<pre><code>
        YYYY-MM-DD
</code></pre>
	<p>The following are the examples of possible input:</p>
	<pre><code>
        2013-03-01
        2012-12-31 // (woo-hoo, it almost a new year!)
</code></pre>
</div>

<div class="code-intro" id="Chapter02-6">
	<p>In the previous recipe we were writing a simple parser for dates. Imagine that some time
	has passed and the task has changed. Now we need to write a date-time parser that will
	support multiple input formats plus zone offsets. So now our parser should understand the
	following inputs:</p>
	<pre><code>
        2012-10-20T10:00:00Z        // date time with zero zone offset
        2012-10-20T10:00:00         // date time with unspecified zone offset
        2012-10-20T10:00:00+09:15   // date time with zone offset
        2012-10-20-09:15            // date time with zone offset
        10:00:09+09:15              // time with zone offset
</code></pre>
</div>




<div class="code-intro" id="Chapter03-0">
	<p>There are situations where we are required to dynamically allocate memory and construct a
	class in that memory. And, that's where the troubles start. Have a look at the following code:</p>
    <pre><code>
    void foo1() {
        foo_class* p = new foo_class("Some initialization data");
        bool something_else_happened = some_function1(p);
        if (something_else_happened) {
            delete p;
            return false;
        }

        some_function2(p);
        delete p;
        return true;
    }
</code></pre>
	<p>This code looks correct at first glance. But, what if <code>some_function1()</code> or <code>some_function2()</code>
	throws an exception? In that case, <code>p</code> won't be deleted. Let's fix it in the
	following way:</p>
    <pre><code>
    void foo2() {
        foo_class* p = new foo_class("Some initialization data");
        try {
            bool something_else_happened = some_function1(p);
            if (something_else_happened) {
                delete p;
                return false;
            }

            some_function2(p);
        } catch (...) {
            delete p;
            throw;
        }

        delete p;
        return true;
    }
</code></pre>
	<p>Now the code is ugly and hard to read but is correct. Maybe we can do better than this.</p>
</div>


<div class="code-intro" id="Chapter03-1">
	<p>Imagine that you have some dynamically allocated structure containing data, and you want
	to process it in different execution threads. The code to do this is as follows:</p>
	<pre><code>
    #include &lt;boost/thread.hpp&gt;
    #include &lt;boost/bind.hpp&gt;
    void process1(const foo_class* p);
    void process2(const foo_class* p);
    void process3(const foo_class* p);

    void foo1() {
        while (foo_class* p = get_data()) // C way
        {
            // There will be too many threads soon, see
            // recipe 'Executing different tasks in parallel'
            // for a good way to avoid uncontrolled growth of threads
            boost::thread(boost::bind(&amp;process1, p))
                .detach();
            boost::thread(boost::bind(&amp;process2, p))
                .detach();
            boost::thread(boost::bind(&amp;process3, p))
                .detach();

            // delete p; Oops!!!!
        }
    }
</code></pre>
	<p>We cannot deallocate <code>p</code> at the end of the while loop because it can still be used by threads
	that run process functions. Process functions cannot delete <code>p</code> because they do not know that
	other threads are not using it anymore.</p>
</div>

<div class="code-intro" id="Chapter03-2">
	<p>We already saw how to manage pointers to a resource in the Managing pointers to classes
	that do not leave scope recipe. But, when we deal with arrays, we need to call <code>delete[]</code>
	instead of a simple delete , otherwise there will be a memory leak. Have a look at the
	following code:</p>
	<pre><code>
    void may_throw1(const char* buffer);
    void may_throw2(const char* buffer);

    void foo() {
        // we cannot allocate 10MB of memory on stack,
        // so we allocate it on heap
        char* buffer = new char[1024 * 1024 * 10];

        // Here comes some code, that may throw
        may_throw1(buffer);
        may_throw2(buffer);

        delete[] buffer;
    }
</code></pre>
</div>

<div class="code-intro" id="Chapter03-3">
	<p>We continue coping with pointers, and our next task is to reference count an array. Let's
	take a look at a program that gets some data from the stream and processes it in different
	threads. The code to do this is as follows:</p>
	<pre><code>
    #include &lt;cstring&gt;
    #include &lt;boost/thread.hpp&gt;
    #include &lt;boost/bind.hpp&gt;

    void do_process(const char* data, std::size_t size);
    void do_process_in_background(const char* data, std::size_t size) {
        // We need to copy data, because we do not know,
        // when it will be deallocated by the caller
        char* data_cpy = new char[size];
        std::memcpy(data_cpy, data, size);

        // Starting thread of execution to process data
        boost::thread(boost::bind(&amp;do_process, data_cpy, size))
            .detach();

        // We cannot delete[] data_cpy, because
        // do_process1 or do_process2 may still work with it
    }
</code></pre>
	<p>Just the same problem that occurred in the <a href="javascript:editor.download('Chapter03', 1)">Reference counting of pointers to classes used across methods</a>
	recipe.</p>
</div>

<div class="code-intro" id="Chapter03-4">
	<p>C++ has a syntax to work with pointers to functions and member functions' pointers. And,
	that is good! However, this mechanism is hard to use with functional objects. Consider the
	situation when you are developing a library that has its API declared in the header files and
	implementation in the source files. This library shall have a function that accepts any functional
	objects. How would you pass a functional object to it? Have a look at the following code:</p>
	<pre><code>
    // Required for std::unary_function&lt;&gt; template
    #include &lt;functional&gt;

    // making a typedef for function pointer accepting int
    // and returning nothing
    typedef void (*func_t)(int);

    // Function that accepts pointer to function and
    // calls accepted function for each integer that it has
    // It cannot work with functional objects :(
    void process_integers(func_t f);

    // Functional object
    class int_processor: public std::unary_function&lt;int, void&gt; {
        const int min_;
        const int max_;
        bool& triggered_;

    public:
        int_processor(int min, int max, bool& triggered)
            : min_(min)
            , max_(max)
            , triggered_(triggered)
        {}

        void operator()(int i) const {
            if (i &lt; min_ || i &gt; max_) {
                triggered_ = true;
            }
        }
    };
</code></pre>
</div>

<div class="code-intro" id="Chapter03-5">
	<p>We are continuing with the previous example, and now we want to pass a pointer to a function
	in our <code>process_integeres()</code> method. Shall we add an overload for just function pointers,
	or is there a more elegant way?</p>
</div>

<div class="code-intro" id="Chapter03-6">
	<p>We are continuing with the previous example, and now we want to use a lambda function with
	our <code>process_integers()</code> method.</p>
</div>

<div class="code-intro" id="Chapter03-7">
	<p>There are such cases when we need to store pointers in the container. The examples are:
	storing polymorphic data in containers, forcing fast copy of data in containers, and strict
	exception requirements for operations with data in containers. In such cases, the C++
	programmer has the following choices:</p>

	<p>* Store pointers in containers and take care of their destructions using the operator
	delete. Such an approach is error prone and requires a lot of writing.</p>

	<p>* Store smart pointers in containers. For the C++03 you'll have to use <code>std::auto_ptr</code>. However the
	<code>std::auto_ptr</code> class is deprecated, and it is not recommended to use it in containers. For the C++11 version
	you'll have to use <code>std::unique_ptr</code>. This solution is a good one, but it cannot be used in C++03, and you still need to
	write a comparator functional object.</p>

	<p>* Use Boost.SmartPtr in the container. This solution is portable, but you still need to write comparators, and it adds
	performance penalties (an atomic counter requires additional memory,
	and its increments/decrements are not as fast as nonatomic operations).</p>
</div>

<div class="code-intro" id="Chapter03-8">
	<p>If you were dealing with languages such as Java, C#, or Delphi, you were obviously using the
	<code>try{} finally{}</code> construction or <code>scope(exit)</code> in the D programming language. Let me
	briefly describe to you what do these language constructions do.</p>

	<p>When a program leaves the current scope via return or exception, code in the finally or
	scope(exit) blocks is executed. This mechanism is perfect for implementing the RAII
	pattern as shown in the following code snippet:</p>
	<pre><code>
    // Some pseudo code (suspiciously similar to Java code)
    try {
        FileWriter f = new FileWriter("example_file.txt");
        // Some code that may trow or return
        // ...
    } finally {
        // Whatever happened in scope, this code will be executed
        // and file will be correctly closed
        if (f != null) {
            f.close()
        }
    }
</code></pre>
	<p>Is there a way to do such a thing in C++?</p>
</div>

<div class="code-intro" id="Chapter03-9">
	<p>We are continuing with the previous example, and now we want to use a lambda function with
	our <code>process_integers()</code> method.</p>
</div>

<div class="code-intro" id="Chapter03-10">
	<p>Let's take a look at the following example. We have some base class that has virtual functions
	and must be initialized with reference to the <code>std::ostream</code> object:</p>
	<pre><code>
    #include &lt;boost/noncopyable.hpp&gt;
    #include &lt;sstream&gt;
    class tasks_processor: boost::noncopyable {
        std::ostream& log_;
    public:
        explicit tasks_processor(std::ostream& log)
            : log_(log)
        {}
    };
</code></pre>

	<p>We also have a derived class that has a std::ostream object:</p>
	<pre><code>
    class fake_tasks_processor: public tasks_processor {
        std::ostringstream logger_;

    public:
        fake_tasks_processor()
            : tasks_processor(logger_) // Oops! logger_ does not exist here
            , logger_()
        {}
    };
</code></pre>
	<p>This is not a very common case in programming, but when such mistakes happen, it is not
	always simple to get the idea of bypassing it. Some people try to bypass it by changing the
	order of <code>logger_</code> and the base type initialization:</p>
    <pre><code>
        fake_tasks_processor()
            : logger_() // Oops! logger_ still will be constructed AFTER tasks_processor
            , tasks_processor(logger_)
        {}
</code></pre>
	<p>It won't work as they expect because direct base classes are initialized before nonstatic
	data members, regardless of the order of the member initializers.</p>
</div>


<div class="code-intro" id="Chapter04-0">
	<p>Let's imagine that we are writing some serialization function that stores values in buffer of a
	specified size:</p>
	<pre><code>
    #include &lt;cstring&gt;
    #include &lt;boost/array.hpp&gt;

    template &lt;class T, std::size_t BufSizeV&gt;
    void serialize(const T&amp; value, boost::array&lt;unsigned char, BufSizeV&gt;&amp; buffer) {
        // TODO: fixme
        std::memcpy(&amp;buffer[0], &amp;value, sizeof(value));
    }
</code></pre>

	<p>This code has the following troubles:</p>
	<p>* The size of the buffer is not checked, so it may overflow</p>
	<p>* This function can be used with non-plain old data (POD) types, which would lead to incorrect behavior</p>

	<p>We may partially fix it by adding some asserts, for example:</p>
	<pre><code>
    template &lt;class T, std::size_t BufSizeV&gt;
    void serialize(const T&amp; value, boost::array&lt;unsigned char, BufSizeV&gt;&amp; buffer) {
        assert(BufSizeV &gt;= sizeof(value));
        // TODO: fixme
        std::memcpy(&amp;buffer[0], &amp;value, sizeof(value));
    }
</code></pre>
	<p>But, this is a bad solution. The <code>BufSizeV</code> and <code>sizeof(value)</code> values are known at compile
	time, so we can potentially make this code to fail compilation if the buffer is too small, instead
	of having a runtime assert (which may not trigger during debug, if function was not called, and
	may even be optimized out in release mode, so very bad things may happen).</p>
</div>

<div class="code-intro" id="Chapter04-1">
	<p>It's a common situation, when we have a templated class that implements some functionality.
	Have a look at the following code snippet:</p>
	<pre><code>
    // Generic implementation
    template &lt;class T&gt;
    class data_processor {
        double process(const T&amp; v1, const T&amp; v2, const T&amp; v3);
    };
</code></pre>
	<p>After execution of the preceding code, we have additional two optimized versions of that class,
	one for integral, and another for real types:</p>
	<pre><code>
    // Integral types optimized version
    template &lt;class T&gt;
    class data_processor {
        typedef int fast_int_t;
        double process(fast_int_t v1, fast_int_t v2, fast_int_t v3);
    };

    // SSE optimized version for float types
    template &lt;class T&gt;
    class data_processor {
        double process(double v1, double v2, double v3);
    };
</code></pre>
	<p>Now the question, how to make the compiler to automatically choose the correct class for a
	specified type, arises.</p>
</div>

<div class="code-intro" id="Chapter04-2">
	<p>We continue working with Boost metaprogramming libraries. In the previous recipe, we saw
	how to use <code>enable_if_c</code> with classes, now it is time to take a look at its usage in template
	functions. Consider the following example.</p>

	<p>Initially, we had a template function that works with all the available types:</p>
	<pre><code>
        template &lt;class T&gt;
        T process_data(const T&amp; v1, const T&amp; v2, const T&amp; v3);
</code></pre>
	Now that we write code using process_data function, we use an optimized process_data
	version for types that do have an <code>operator +=</code> function:
	<pre><code>
        template &lt;class T&gt;
        T process_data_plus_assign(const T&amp; v1, const T&amp; v2, const T&amp; v3);
</code></pre>
	<p>But, we do not want to change the already written code; instead whenever it is possible, we
	want to force the compiler to automatically use optimized function in place of the default one.</p>
</div>

<div class="code-intro" id="Chapter04-3">
	<p>We have now seen examples of how we can choose between functions without
	<code>boost::enable_if_c</code> usage. Let's consider the following example, where we have a generic
	method for processing POD datatypes:</p>
	<pre><code>
    #include &lt;boost/static_assert.hpp&gt;
    #include &lt;boost/type_traits/is_pod.hpp&gt;

    // Generic implementation
    template &lt;class T&gt;
    T process(const T&amp; val) {
        BOOST_STATIC_ASSERT((boost::is_pod&lt;T&gt;::value));
        // ...
    }
</code></pre>

	<p>And, we have the same function optimized for sizes 1, 4, and 8 bytes. How do we rewrite
	process function, so that it can dispatch calls to optimized versions?</p>
</div>


<div class="code-intro" id="Chapter04-4">
	<p>We need to implement a type trait that returns <code>true</code> if the <code>std::vector</code> type is passed to it
	as a template parameter.</p>
</div>

<div class="code-intro" id="Chapter04-5">
	<p>Imagine that we are working with classes from different vendors that implement different
	amounts of arithmetic operations and have constructors from integers. And, we do want to
	make a function that increments by one when any class is passed to it. Also, we want this
	function to be effective! Take a look at the following code:</p>
	<pre><code>
    template &lt;class T&gt;
    void inc(T&amp; value) {
        // call ++value
        // or call value ++
        // or value += T(1);
        // or value = value + T(1);
    }
</code></pre>
</div>


<div class="code-intro" id="Chapter04-6">
	<p>In the previous recipes, we saw some examples on <code>boost::bind</code> usage. It is a good and
	useful tool with a small drawback; it is hard to store <code>boost::bind</code> metafunction's functor
	as a variable in C++03.</p>
	<pre><code>
    #include &lt;functional&gt;
    #include &lt;boost/bind.hpp&gt;
    const ??? var = boost::bind(std::plus&lt;int&gt;(), _1, _1);
</code></pre>
	<p>In C++11, we can use auto keyword instead of <code>???</code> , and that will work. Is there a way to
	do it in C++03?</p>
</div>


<div class="code-intro" id="Chapter05-0">
	<p>On modern multi-core compilers, to achieve maximal performance (or just to provide a good
	user experience), programs usually must use multiple execution threads. Here is a motivating
	example in which we need to create and fill a big file in a thread that draws the user interface:</p>
	<pre><code>
    #include &lt;algorithm&gt;
    #include &lt;fstream&gt;
    #include &lt;iterator&gt;

    void set_not_first_run();
    bool is_first_run();

    // Function, that executes for a long time
    void fill_file_with_data(char fill_char, std::size_t size, const char* filename) {
        std::ofstream ofs(filename);
        std::fill_n(std::ostreambuf_iterator&lt;char&gt;(ofs), size, fill_char);
        set_not_first_run();
    }

    // ...
    // Somewhere in thread that draws a user interface
    if (is_first_run()) {
        // This will be executing for a long time during which
        // user's interface will freeze.
        fill_file_with_data(0, 8 * 1024 * 1024, "save_file.txt");
    }
</code></pre>
</div>

<div class="code-intro" id="Chapter05-1">
	<p>Now that we know how to start execution threads, we want to have access to some common
	resources from different threads:</p>
	<pre><code>
    #include &lt;cassert&gt;
    #include &lt;cstddef&gt;
    // In previous recipe we included
    // &lt;boost/thread.hpp&gt;, which includes all
    // the classes of Boost.Thread
    #include &lt;boost/thread/thread.hpp&gt;

    int shared_i = 0;

    void do_inc() {
        for (std::size_t i = 0; i &lt; 30000; ++i) {
            // do some work
            // ...
            const int i_snapshot = ++ shared_i;
            // do some work with i_snapshot
            // ...
        }
    }

    void do_dec() {
        for (std::size_t i = 0; i &lt; 30000; ++i) {
            // do some work
            // ...
            const int i_snapshot = -- shared_i;
            // do some work with i_snapshot
            // ...
        }
    }

    void run() {
        boost::thread t1(&amp;do_inc);
        boost::thread t2(&amp;do_dec);

        t1.join();
        t2.join();

        // assert(shared_i == 0); // Oops!
        std::cout &lt;&lt; "shared_i == " &lt;&lt; shared_i;
    }
</code></pre>
	<p>This <code>'Oops!'</code> is not written there accidentally. For some people it will be a surprise, but there
	is a big chance that shared_i won't be equal to 0:</p>
	<pre><code>
        shared_i == 19567
</code></pre>

	<p>And it will get even worse in cases when a common resource has some non-trivial classes;
	segmentation faults and memory leaks may (and will) occur.
	We need to change the code so that only one thread modifies the shared_i variable at a
	single moment of time and so that all of the processor and compiler optimizations that inflict
	multithreaded code are bypassed.</p>
</div>

<div class="code-intro" id="Chapter05-2">
	<p>In the previous recipe, we saw how to safely access a common resource from different
	threads. But in that recipe, we were doing two system calls (in locking and unlocking the
	mutex) just to get the value from an integer:</p>
	<pre><code>
    { // Critical section begin
        boost::lock_guard&lt;boost::mutex&gt; lock(i_mutex);
        i_snapshot = ++ shared_i;
    } // Critical section end
</code></pre>

	<p>This looks lame! And slow! Can we make the code from the previous recipe better?</p>
</div>

<div class="code-intro" id="Chapter05-3">
	<p>Let's for shortness call the functional object that takes no arguments a task.</p>
	<pre><code>
    typedef boost::function&lt;void()&gt; task_t;
</code></pre>
	<p>And now, imagine a situation where we have threads that post tasks and threads that execute
	posted tasks. We need to design a class that can be safely used by both types of thread. This
	class must have methods for getting a task (or blocking and waiting for a task until it is posted
	by another thread), checking and getting a task if we have one (returning an empty task if no
	tasks remain), and a method to post tasks.</p>
</div>

<div class="code-intro" id="Chapter05-4">
	<p>Imagine that we are developing some online services. We have a map of registered users
	with some properties for each user. This set is accessed by many threads, but it is very rarely
	modified. All operations with the following set are done in a thread-safe manner via acquireing an unique lock on the mutex.</p>

	<p>But any operation, even getting/reading
	resources will result in waiting on a locked mutex; therefore, this class will become a
	bottleneck very soon.</p>

	<p>Can we fix it?</p>
</div>

<div class="code-intro" id="Chapter05-5">
	<p>Let's take a glance at the recipe Creating a work_queue class. Each task there can be
	executed in one of many threads and we do not know which one. Imagine that we want to
	send the results of an executed task using some connection.</p>
	<pre><code>
    #include &lt;boost/noncopyable.hpp&gt;
    class connection: boost::noncopyable {
    public:
        // Opening a connection is a slow operation
        void open();

        void send_result(int result);
        // Other methods
        // ...
    };
</code></pre>

	<p>We have the following solutions:</p>
	<p>* Open a new connection when we need to send the data (which is slow)</p>
	<p>* Have a single connection for all the threads and wrap them in mutex
	(which is also slow)</p>
	<p>* Have a pool of connections, get a connection from it in a thread-safe manner
	and use it (a lot of coding is required, but this solution is fast)</p>
	<p>* Have a single connection per thread (fast and simple to implement)</p>

	<p>So, how can we implement the last solution?</p>
</div>

<div class="code-intro" id="Chapter05-6">
	<p>Sometimes, we need to kill a thread that ate too many resources or that is just executing for
	too long. For example, some parser works in a thread (and actively uses Boost.Thread),
	but we already have the required amount of data from it, so parsing can be stopped. All we
	have is:</p>
	<pre><code>
    boost::thread parser_thread(&amp;do_parse);

    // Some code goes here
    // ...
    if (stop_parsing) {
        // no more parsing required
        // TODO: stop parser
    }
</code></pre>
	<p>How can we do it?</p>
</div>

<div class="code-intro" id="Chapter05-7">
	<p>Those readers who were trying to repeat all the examples by themselves or those who were
	experimenting with threads must already be bored with writing the following code to launch
	threads:</p>
	<pre><code>
    boost::thread t1(&amp;some_function);
    boost::thread t2(&amp;some_function);
    boost::thread t3(&amp;some_function);
    // ...
    t1.join();
    t2.join();
    t3.join();
</code></pre>
	<p>Maybe there is a better way to do this?</p>
</div>

<div class="code-intro" id="Chapter06-0">
	<p>First of all, let's take care of the class that will hold all the tasks and provide methods for their
	execution. We were already doing something like this in the Creating a work_queue class
	recipe, but some of the following problems were not addressed:</p>
	<p>* A task may throw an exception that leads a call to std::terminate</p>
	<p>* An interrupted thread may not notice interruption but will finish its task and interrupt
	only during the next task (which is not what we wanted; we wanted to interrupt the
	previous task)</p>
	<p>* Our work_queue class was only storing and returning tasks, but we need to add
	methods for executing existing tasks</p>
	<p>* We need a way to stop processing the tasks</p>
</div>

<div class="code-intro" id="Chapter06-1">
	<p>It is a common task to check something at specified intervals; for example, we need to check
	some session for an activity once every 5 seconds. There are two popular solutions to such
	a problem: creating a thread or sleeping for 5 seconds. This is a very lame solution that
	consumes a lot of system resources and scales badly. We could instead use system specific
	APIs for manipulating timers asynchronously. This is a better solution, but it requires a lot of
	work and is not very portable (until you write many wrappers for different platforms). It also
	makes you work with OS APIs that are not always very nice.</p>
</div>

<div class="code-intro" id="Chapter06-2">
	<p>Receiving or sending data by network is a slow operation. While packets are received by the
	machine, and while the OS verifies them and copies the data to the user-specified buffer,
	multiple seconds may pass. And we may be able to do a lot of work instead of waiting. Let's
	modify our tasks_processor class so that it will be capable of sending and receiving
	data in an asynchronous manner. In nontechnical terms, we ask it to "receive at least N
	bytes from the remote host and after that is done, call our functor. And by the way, do not
	block on this call". Those readers who know about libev , libevent , or Node.js will find
	a lot of familiar things in this recipe.</p>
</div>

<div class="code-intro" id="Chapter06-3">
	<p>A server side working with a network usually looks like a sequence where we first get
	data, then process it, and then send the result. Imagine that we are creating some kind of
	authorization server that will process a huge number of requests per second. In that case,
	we will need to receive and send data asynchronously and process tasks in multiple threads.</p>
	<p>In this recipe, we'll see how to extend our tasks_processor class to accept and process
	incoming connections, and in the next recipe, we'll see how to make it multithreaded.</p>
</div>

<div class="code-intro" id="Chapter06-4">
	<p>Now it is time to make our <code>tasks_queue</code> process tasks in multiple threads. How hard could
	this be?</p>
</div>

<div class="code-intro" id="Chapter06-5">
	<p>Sometimes there is a requirement to process tasks within a specified time interval. Compared
	to previous recipes, where we were trying to process tasks in the order of their appearance in
	the queue, this is a big difference.</p>
	<p>Consider an example where we are writing a program that connects two subsystems, one of
	which produces data packets and the other writes modified data to the disk (something like
	this can be seen in video cameras, sound recorders, and other devices). We need to process
	data packets one by one, smoothly with the least jitter, and in multiple threads.</p>
	<p>Our previous tasks_queue was bad at processing tasks in a specified order, so how can we solve this?</p>
</div>

<div class="code-intro" id="Chapter06-6">
	<p>In multithreaded programming, there is an abstraction called barrier. It stops execution
	of threads that reach it until the requested number of threads are not blocked on it. After that,
	all the threads are released and they continue with their execution.</p>

	<p>For example, we want to process different parts of the data in different threads and then send the data:</p>
	<pre><code>
    void runner(std::size_t thread_index, boost::barrier&amp; data_barrier, data_t&amp; data) {
        for (std::size_t i = 0; i &lt; 1000; ++ i) {
            fill_data(data.at(thread_index));
            data_barrier.wait();

            if (!thread_index) {
                compute_send_data(data);
            }

            data_barrier.wait();
        }
    }
</code></pre>
	<p>The <code>data_barrier.wait()</code> method blocks until all the threads fill the data. After that,
	all the threads are released; the thread with the index 0 will compute data to be sent using
	<code>compute_send_data(data)</code>, while others are again waiting at the barrier.</p>

	<p>Looks lame, isn't it?</p>
</div>

<div class="code-intro" id="Chapter06-7">
	<p>Processing exceptions is not always trivial and may take a lot of time. Consider the situation
	where an exception must be serialized and sent by the network. This may take milliseconds
	and a few thousand lines of code. After the exception is caught is not always the best time
	and place to process it.</p>
	<p>So, can we store exceptions and delay their processing?</p>
</div>

<div class="code-intro" id="Chapter06-8">
	<p>When writing some server applications (especially for Linux OS), catching and processing
	signals is required. Usually, all the signal handlers are set up at server start and do not
	change during the application's execution.</p>
	<p>The goal of this recipe is to make our <code>tasks_processor</code> class capable of processing signals.</p>
</div>

							</div>
						</div>

						<div class="container">
							<div id="online_run" class="right" style="margin: 0.5em 0.5em">
								<button id="run" onclick='editor.run();'>Run</button> 
								<button id="compile" onclick='editor.compile();'>Compile</button>
							</div>
							<h3>Compile &amp; Run</h3>

							<div class="width100 left">
								<p class="nowrap">Program arguments: <input class="width100" id="input"/></p>
								<p class="nowrap">Compilation command: <input class="width100" id="compile_command"/></p>
								<p class="nowrap">Output:</p><pre id="output" style="margin-top: 0; margin-left: 25px; background: #fff;">Waiting...</pre>
								<p id="runtime-issues" class="nowrap text-center hidden">This recipe has <span style="color: red;">runtime issues</span> because of the limited capabilities of online executor.</p>
								<p id="compile-issues" class="nowrap text-center hidden">This recipe has <span style="color: red;">compile issues</span> because of the limited capabilities of online compiler.</p>
								<p class="nowrap left">Code (editable):</p><div id="code" style="width: 100%">... downloading ...</div>
								<p class="nowrap right">In <a href="http://www.packtpub.com/boost-cplusplus-application-development-cookbook/book">the book
									you'll also find</a>: in-depth description of each recipe, performance notes, comparison with C++11/C++14 and other juicy stuff.
								</p>
							</div>
						</div>
					</section>

					<section id="about" class="four">
						<div class="container">

							<header>
								<h2>About</h2>
							</header>

							<p>
								Hi, I'm Antony Polukhin and I'm the author of Boost.TypeIndex and Boost.DLL,
								maintainer of multiple Boost's libraries and mentor in the Google
								Summer of Code programs.
							</p>
							<p>
								I hope that this site will be
								useful for you. Do the online compilation of Boost related examples, modify
								source codes, run tests and play around with Boost libraries.
							</p>
							<p>
								All the examples on this site are additionaly explained in the 
								<a href="http://www.packtpub.com/boost-cplusplus-application-development-cookbook/book">
								Boost Application Development Cookbook</a>, along with C++11 and performance notes. All the
								<a href="https://github.com/apolukhin/Boost-Cookbook-4880OS">source codes are available on guthub</a>.
							</p>
						</div>
					</section>

					<section id="acknowledgements" class="two">
						<div class="container">

							<header>
								<h2>Thanks</h2>
							</header>

								<div class="left">
									Without following people, this site (and the book) could not exist:
									<ul>
										<li>
											All the people who participate in Boost libraries development. Without them,
											there'll be no Boost, no book, no hobbie.
										</li>
										<li>
											Wonderfull people from Coliru, that allow users to do online compilations.
										</li>
										<li>
											Heather Gopsill and Lakhi Dhatt from Packt Publishing for giving a permission to make sources and recipes' introductions publicly available.
										</li>
									</ul>
								</div>

						</div>
					</section>

			</div>

		<!-- Footer -->
			<div id="footer">

				<!-- Copyright -->
					<ul class="copyright">
						<li>Design: <a href="http://html5up.net" rel="nofollow" target="_blank">HTML5 UP</a></li>
					</ul>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.scrollzer.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/util.min.js"></script>
			<!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="assets/js/main.min.js"></script>
			<script src="assets/js/ace/ace.js"></script>
			<script src="assets/js/cppeditor.min.js"></script>
			<script>
				$(function() {
					editor.init(ace.edit("code"), $("#input"), $("#output"), $("#recipe_title"), $("#compile_command"));
				});
			</script>
	</body>
</html>
